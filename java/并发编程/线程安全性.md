# 什么是线程安全性

    当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程讲如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。原子性，可见性，有序性。

# 原子性

    互斥机制，同一时刻只能有一个线程操作数据
    Atomic包：CAS、Unsafe.compareAndSwapInt:循环判断期望值与底层的值是否相等，相等则更新。
    LongAddr:
    AtomicStampReference:CAS的ABA问题

## 锁

    synchronized:依赖JVM
        修饰代码块和方法，作用于调用的对象
        修饰静态方法和类，作用于所有对象
    Lock：以来特殊的CPU指令，代码实现，ReentrantLock
### synchronized、Lock、Atomic的比较

    synchronized：不可中断锁，适合竞争不激烈，可读性好
    Lock：可中断锁，多样化同步，竞争激烈时能维持常态
    Atomic:竞争激烈时能维持常态，比Lock性能好，只能同步一个值

# 可见性

    导致共享变量在线程间不可见的原因：
    1.线程交叉执行
    2.重排序结合线程交叉执行
    3.共享变量更新后的值没有在工作内存与主存间即时更新

## synchronized的可见性

    1.线程加锁前，必须把共享变量的最新值刷新到主存
    2.线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主存中重新读取最新值

## volatile的可见性

    1.加屏障-cpu指令级别
    2.禁止指令重排序

# 有序性

    happens-before原则